<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript" src="https://livejs.com/live.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.47/moment-timezone-with-data.min.js"></script>
    <title>DASH</title>
    <script>// -- https://xemantic.github.io/shader-web-background/
        const shaderWebBackground = {}; (() => {
            'use strict'; const t = (a, b) => {
                b.initHalfFloatRGBATexture(b.width, b.height); a.texParameteri(a.TEXTURE_2D,
                    a.TEXTURE_MIN_FILTER, a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER,
                        a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE); a.texParameteri(a.TEXTURE_2D,
                            a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE)
            }, x = (a, b) => {
                console.warn("shader-web-background cannot shade, adding fallback CSS classes");
                document.documentElement.classList.add("shader-web-background-fallback"); b.classList.add("shader-web-background-fallback");
                if (a instanceof shaderWebBackground.GlError) console.warn("Not sufficient WebGL support:",
                    a); else throw a;
            };
            function y(a, b) { if (!a) throw new shaderWebBackground.ConfigError(b); }
            function z(a) {
                y(a instanceof HTMLCanvasElement, "config.canvas must be instance of canvas");
                return a
            }
            function A() {
                const a = document.createElement("canvas"), b = a.style; a.id = "shader-web-background"; b.width =
                    "100vw"; b.height = "100vh"; b.position = "fixed"; b.top = "0"; b.left = "0"; b.zIndex = -9999; return a
            }
            function B(a, b, c) {
                y(a instanceof HTMLScriptElement && a.type === b, 'Shader source element of id "' +
                    c + '" should be of type: <script type="' + (b + '" id="' + c + '">'))
            }
            function D(a) {
                const b = document.getElementById(a); y(b, 'Missing shader source: <script type="x-shader/x-fragment" id="' +
                    (a + '">')); B(b, "x-shader/x-fragment", a); return b.text
            }
            function E(a) {
                a += "Vertex"; const b = document.getElementById(a); return b ? (B(b, "x-shader/x-vertex",
                    a), b.text) : "attribute vec2 V;void main(){gl_Position=vec4(V,0,1);}"
            }
            function F(a, b) { "loading" !== document.readyState ? b() : window.addEventListener(a, b) }
            class G {
                constructor(a, b, c, d) {
                    this.g = c; const l = a.gl; this.h = () => {
                        for (const f of d) f.u(l,
                            f.location, b)
                    }; this.i = () => {
                        var f = c.v, h = a.gl; h.bindBuffer(h.ARRAY_BUFFER, a.j); h.enableVertexAttribArray(f);
                        h.vertexAttribPointer(f, 2, h.FLOAT, !1, 0, 0); h.drawArrays(h.TRIANGLE_STRIP, 0, 4); h.disableVertexAttribArray(f);
                        h.bindBuffer(h.ARRAY_BUFFER, null); f = a.gl; for (h = 0; h < a.g; h++)f.activeTexture(f.TEXTURE0 +
                            h), f.bindTexture(f.TEXTURE_2D, null); a.g = 0
                    }
                }
            }
            function H(a) {
                var b = { antialias: !1, depth: !1, alpha: !1 }; try { return new I(a, b) } catch (c) {
                    throw new shaderWebBackground.GlError(c.message);
                }
            }
            function J(a, b, c, d, l, f) {
                function h(e, m, n) {
                    try {
                        {
                            var k = p; const q = k.gl, P = K(k, e, q.VERTEX_SHADER, m),
                                Q = K(k, e, q.FRAGMENT_SHADER, n), v = q.createProgram(); q.attachShader(v, P); q.attachShader(v,
                                    Q); q.linkProgram(v); var r = v
                        } return r
                    } catch (q) {
                        throw new shaderWebBackground.ConfigError(q.message);
                    }
                } const p = H(a), w = [], g = {
                    gl: p.gl, canvas: a, width: 0, height: 0, cssPixelRatio: 0, cssWidth: 0,
                    cssHeight: 0, isOverShader: (e, m) => {
                        const n = a.getBoundingClientRect(); return e >= n.left &&
                            e <= n.right && m >= n.top && m <= n.bottom
                    }, toShaderX: e => (e - a.getBoundingClientRect().left) *
                        g.cssPixelRatio + .5, toShaderY: e => a.height - (e - a.getBoundingClientRect().top) * g.cssPixelRatio -
                            .5, s: () => g.cssWidth !== a.clientWidth || g.cssHeight !== a.clientHeight ? (g.resize(), !0) :
                                !1, resize: () => {
                                    const e = window.devicePixelRatio || 1, m = a.clientWidth, n = a.clientHeight,
                                    k = Math.floor(m * e), r = Math.floor(n * e); a.width = k; a.height = r; g.width = k; g.height = r; g.cssPixelRatio =
                                        e; g.cssWidth = m; g.cssHeight = n; p.gl.viewport(0, 0, p.canvas.width, p.canvas.height); for (const q of w) q.g.l(k,
                                            r)
                                }, texture: (e, m) => {
                                    {
                                        var n = p; const k = n.gl; m = m instanceof L ? m.g : m; k.activeTexture(k.TEXTURE0 +
                                            n.g); k.bindTexture(k.TEXTURE_2D, m); k.uniform1i(e, n.g++)
                                    }
                                }, buffers: {}, initHalfFloatRGBATexture: (e,
                                    m) => { p.h.g(e, m) }
                }, R = Object.keys(b).length - 1; let S = 0; for (const e in b) {
                    if (S++ < R) {
                        const k =
                            b[e].texture || t; g.buffers[e] = M(p, () => { k(p.gl, g) })
                    } const m = N(p, h(e, E(e), D(e)), g.buffers[e]),
                        n = b[e].uniforms || {}; var u = Object.keys(n); for (const k of m.m) y(n[k.name], 'No configuration for uniform "' +
                            k.name + '" defined in shader "' + e + '"'), u = u.filter(r => r !== k.name); 0 !== u.length && console.warn('Extra uniforms configured for shader "' +
                                e + '", which are not present in the shader code - might have been removed by GLSL compiler if not used: ' +
                                u.join(", ")); u = m.m.map(k => ({ location: k.location, u: n[k.name] })); w.push(new G(p, g,
                                    m, u))
                } const C = () => {
                    g.s() && d && d(g.width, g.height, g); l && l(g); for (const e of w) e.g.i(e.h,
                        e.i); f && f(g); requestAnimationFrame(C)
                }; F("load", () => {
                    g.resize(); c && c(g); d && d(g.width,
                        g.height, g); requestAnimationFrame(C)
                }); return g
            }
            shaderWebBackground.Error = class extends Error { constructor(a) { super(a); this.name = "shaderWebBackground.Error" } };
            shaderWebBackground.ConfigError = class extends shaderWebBackground.Error {
                constructor(a) {
                    super(a);
                    this.name = "shaderWebBackground.ConfigError"
                }
            };
            shaderWebBackground.GlError = class extends shaderWebBackground.Error {
                constructor(a) {
                    super(a); this.name =
                        "shaderWebBackground.GlError"
                }
            };
            shaderWebBackground.shade = function (a) {
                y(a, "Missing config argument"); const b = a.canvas ?
                    z(a.canvas) : A(); y(a.shaders, "No shaders specified in config"); try {
                        const c = J(b, a.shaders,
                            a.onInit, a.onResize, a.onBeforeFrame, a.onAfterFrame); a.canvas || F("DOMContentLoaded",
                                () => { document.body.appendChild(b) }); return c
                    } catch (c) { (a.onError || x)(c, b) }
            }; const O = [-1, 1, 1, 1, -1, -1, 1, -1];
            function T(a, b) { return a.j(a.gl.getExtension(b), b + " extension is not supported") }
            class U { constructor(a, b) { this.gl = a; this.j = b } g() { } }
            class V extends U {
                constructor(a, b) {
                    super(a, b); this.h = T(this, "OES_texture_half_float");
                    T(this, "OES_texture_half_float_linear")
                } g(a, b) {
                    const c = this.gl; c.texImage2D(c.TEXTURE_2D,
                        0, c.RGBA, a, b, 0, c.RGBA, this.h.HALF_FLOAT_OES, null)
                }
            }
            class W extends U {
                constructor(a, b) { super(a, b); T(this, "EXT_color_buffer_float"); this.gl.getExtension("OES_texture_float_linear") } g(a,
                    b) {
                        const c = this.gl; c.texImage2D(c.TEXTURE_2D, 0, c.RGBA16F, a, b, 0, c.RGBA, c.HALF_FLOAT,
                            null)
                }
            }
            function X(a) {
                a = a.split(/\r?\n/); const b = a.length.toString().length; var c = []; a.forEach((d,
                    l) => {
                        l = (l + 1).toString(); l = l.length >= b ? l : " ".repeat(b - l.length) + l; c.push(l + ": " + d +
                            "\n")
                }); return c.join("")
            } function M(a, b) { return new L(a.gl, () => { b(a.gl) }) }
            function N(a, b, c) {
                const d = a.gl; a = []; const l = d.getProgramParameter(b, d.ACTIVE_UNIFORMS);
                for (let f = 0; f < l; f++) {
                    const h = d.getActiveUniform(b, f); a.push({
                        name: h.name, location: d.getUniformLocation(b,
                            h.name)
                    })
                } return {
                    v: d.getAttribLocation(b, "V"), m: a, l: c ? (f, h) => c.l(f, h) : () => { }, i: (f,
                        h) => { d.useProgram(b); f(); c ? (f = c.g, c.g = c.h, c.h = f, c.i(h)) : h() }
                }
            }
            function K(a, b, c, d) {
                a = a.gl; c = a.createShader(c); a.shaderSource(c, d); a.compileShader(c);
                if (!a.getShaderParameter(c, a.COMPILE_STATUS)) {
                    const l = String(a.getShaderInfoLog(c));
                    a.deleteShader(c); b = "Cannot compile shader - " + b + ": " + l; console.log(b); console.log(X(d));
                    throw Error(b);
                } return c
            }
            class I {
                constructor(a, b) {
                    this.canvas = a; const c = (l, f) => { if (!l) throw Error(f); return l };
                    let d = a.getContext("webgl2", b); if (d) this.h = new W(d, c); else if (d = a.getContext("webgl",
                        b)) this.h = new V(d, c); c(d, "webgl context not supported on supplied canvas element: " +
                            a); this.gl = d; a = d.createBuffer(); d.bindBuffer(d.ARRAY_BUFFER, a); d.bufferData(d.ARRAY_BUFFER,
                                new Float32Array(O), d.STATIC_DRAW); d.bindBuffer(d.ARRAY_BUFFER, null); this.j = a; this.buffers =
                                    {}; this.g = 0
                }
            }
            function Y(a) {
                const b = a.gl, c = b.createTexture(); b.bindTexture(b.TEXTURE_2D, c); a.o(b);
                b.bindTexture(b.TEXTURE_2D, null); return c
            }
            class L {
                constructor(a, b) {
                    this.j = a.createFramebuffer(); this.gl = a; this.o = b; this.g = this.h =
                        null
                } l() {
                    this.h && this.gl.deleteTexture(this.h); this.g && this.gl.deleteTexture(this.g);
                    this.h = Y(this); this.g = Y(this)
                } i(a) {
                    const b = this.gl; b.bindFramebuffer(b.FRAMEBUFFER,
                        this.j); b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, this.g,
                            0); a(); b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, null,
                                0); b.bindFramebuffer(b.FRAMEBUFFER, null)
                }
            };
        })()
        //# sourceMappingURL=shader-web-background.min.js.map</script>


    <script type="x-shader/x-fragment" id="image">



            precision highp float;
            uniform vec2  iResolution;

            uniform float iTime;
            vec3 rgb2hsv(vec3 c)
            {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            vec3 hsv2rgb(vec3 c)
            {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
          
            vec3 ScreenSpaceDither(vec2 vScreenPos, float colorDepth)
            {
                // lestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR
                vec3 vDither = vec3(dot(vec2(131.0, 312.0), vScreenPos.xy + iTime));
                vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);
                return (vDither.rgb / colorDepth) * 0.375;
            }
            void bub(inout vec4 fragColor, in vec2 fragCoord, float radius, vec2 bubbleCenter, vec3 bubbleColor, float exp) {
                    float dis = length( fragCoord - bubbleCenter);
                    float disN = dis/radius;
                    if (dis < radius) {
                        fragColor.xyz += pow((1.-disN),exp)*bubbleColor;
                    }
            }
            void slideBub(inout vec4 fragColor, in vec2 fragCoord, float radius, vec2 speed, vec3 bubbleColor, float exp) {
                vec2 bubbleCenter;
                bubbleCenter = (sin(iTime*speed+speed*500.)*iResolution.xy+iResolution.xy)/2.;
                bub(fragColor, fragCoord, radius, bubbleCenter, bubbleColor, exp);
            }
            
            
            float myTime = 0.;
            float oldTime = 0.;
            void mainImage( out vec4 fragColor, in vec2 fragCoord )
            {
                float scale = (iResolution.x + iResolution.y)/2.;
                fragColor = vec4(0.0,0.0,0.0,1.0);
            
                
                float divvy = .999;
                float size = 3.;
                vec3 pink = vec3(1.,.5, 1.);
                vec3 yellow = vec3(1.,1.,.5);
                vec3 blue = vec3(0.5,.9,1.0);
                vec3 lightPink = vec3(1.,.9,1.);
                vec3 white = vec3(1.,1.,1.);
                slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.11/divvy,.16/divvy), pink,5.);
                divvy *= 1.1;
                //slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.13/divvy), yellow, 5.);
                divvy *= 1.1;
                slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.14/divvy), blue, 5.);
                divvy *= 1.1;
                //slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.15/divvy), lightPink,5.);
                divvy *= 1.13;
                //slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.11/divvy,.16/divvy), pink,5.);
                divvy *= 1.1;
                slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.13/divvy), yellow, 5.);
                divvy *= 1.1;
                slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.14/divvy), blue,5.);
                divvy *= 1.1;
                slideBub(fragColor, fragCoord, iResolution.y*size/divvy, vec2(.1/divvy,.15/divvy), lightPink,5.);
                //slideBub(fragColor, fragCoord, iResolution.y*1., vec2(.1,.003), white, 5.);
                //fragColor += fragColor;
                //fragColor += fragColor;
                //fragColor += fragColor;
                //fragColor += fragColor;
                //fragColor += fragColor;
                //fragColor += fragColor;
                fragColor *= fragColor;
                //fragColor *= fragColor;
                //fragColor += fragColor;
                //fragColor *= fragColor;
                //fragColor *= fragColor;
                //fragColor += fragColor;
                //fragColor += fragColor;
                
                
                
                //fragColor += (vec4(rand(), rand(), rand(), 1.)-.5)/10.;
                fragColor = vec4(rgb2hsv(fragColor.xyz), fragColor.w);
                fragColor.x *= 2.0;
                fragColor.z *= -1.0;
                fragColor.z += 1.0;
                fragColor.z *= 0.125;
                fragColor.z *= fragColor.z;
                fragColor.z *= fragColor.z;
                fragColor = vec4(hsv2rgb(fragColor.xyz), fragColor.w);
                fragColor += vec4(ScreenSpaceDither(fragCoord.xy, 20.0), 1.);
                if (fragColor.x < 0.0) fragColor.x = 0.0;
                if (fragColor.y < 0.0) fragColor.y = 0.0;
                if (fragColor.z < 0.0) fragColor.z = 0.0;
                //fragColor.xyz += fragColor.xyz;
                //fragColor.xyz += fragColor.xyz;

            }
            
            


            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
              }


          </script>
    <script>

        shaderWebBackground.shade({
            shaders: {
                image: {
                    uniforms: {
                        iResolution: (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
                        iTime: (gl, loc) => gl.uniform1f(loc, performance.now() / 1000)
                    }
                }
            }
        });

    </script>
    <style>
    * {
        color: black;
        text-shadow: 0.125vmin 0.125vmin 0.25vmin white, -0.125vmin -0.125vmin 0.25vmin white, 0.125vmin -0.125vmin 0.25vmin white, -0.125vmin 0.125vmin 0.25vmin white,0.125vmin 0.125vmin 0.25vmin white, -0.125vmin -0.125vmin 0.25vmin white, 0.125vmin -0.125vmin 0.25vmin white, -0.125vmin 0.125vmin 0.25vmin white, 0.125vmin 0.125vmin 0.25vmin white, -0.125vmin -0.125vmin 0.25vmin white, 0.125vmin -0.125vmin 0.25vmin white, -0.125vmin 0.125vmin 0.25vmin white,0.125vmin 0.125vmin 0.25vmin white, -0.125vmin -0.125vmin 0.25vmin white, 0.125vmin -0.125vmin 0.25vmin white, -0.125vmin 0.125vmin 0.25vmin white;
        paint-order: stroke;
    }

    .background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
    }

    iframe {
        position: relative;
        width: 100%;
    }

    content {}


    @font-face {
        font-family: 'Droid Sans Mono';
        src: url(DroidSansMono.ttf);
    }
    html,
    body {
        font-family: 'Droid Sans Mono', monospace;
        text-align: center;
        font-size: 10vmin;
        overflow: hidden;
    }


    div.outer-div {
        height: 100%;
        width: 100%;
        animation-name: inoutbg;
        animation-duration: 12s;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
    }



    #time {
        animation-name: inoutsm;
        animation-duration: 1s;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
    }

    @keyframes inoutbg {
        0% {
            transform: scale(0.9, 0.9) translate(0vh,-20vh);
        }

        50% {
            transform: scale(0.75, 0.75) translate(0vh,20vh);
        }

        100% {
            transform: scale(0.9, 0.9) translate(0vh,-20vh);
        }
    }

    @keyframes inoutsm {
        0% {
            transform: scale(1, 1);
        }

        50% {
            transform: scale(1.02, 1.02);
        }

        100% {
            transform: scale(1, 1);
        }
    }

    div.middle-div {
        position: relative;
    }



    </style>
</head>

<body>
    <div class="page">
        <content>
            <div class='outer-div'>
                <div class='middle-div'>
                    <div style="font-size: 20vh; padding: 0;margin: 0;">
                    <span >&nbsp;</span>
                    </div>
                    <div id="minfo" style="font-size:25vmin">
                        <span id="wday"></span>
                        <span id="temp"></span><span id="dp" style="opacity: .15;"></span>
                    </div>
                    <div id="day" style=""></div>
                    <div id="time" style="font-size: 17vmin;"></div>
                    <br>
                    <div style="font-size: 5vmin;">Calif (Pacific): <span id="caltim">xx</span></div>
                    <div style="font-size: 5vmin;">Ariz (Mntn Std): <span id="arztim">xx</span></div>
                    <div style="font-size: 5vmin;">Nash/Tex (Cent): <span id="nshtim">xx</span></div>
                    <br>
                    <div style="font-size: 5vmin;">Reykjav&#x00ED;k (UTC): <span id="utctim">xx</span></div>
                    <div style="font-size: 5vmin;">Frnc (Cent Eur): <span id="frntim">xx</span></div>
                    <div style="font-size: 20vh; padding: 0;margin: 0;">
                    <span >&nbsp;</span>
                    </div>
                </div>
            </div>

    <script>
    const momentProxy = (arg1) => moment(arg1);
    const urlParams = new URLSearchParams(window.location.search);
    const appid = urlParams.get('appid');
    setInterval(() => {
        document.getElementById("time").innerText = momentProxy().format('h:mm:ss');
        document.getElementById("caltim").innerText = momentProxy().tz('America/Los_Angeles').format('hh:mm:ss A');
        document.getElementById("arztim").innerText = momentProxy().tz('America/Phoenix').format('hh:mm:ss A');
        document.getElementById("nshtim").innerText = momentProxy().tz('America/Chicago').format('hh:mm:ss A');
        document.getElementById("utctim").innerText = momentProxy().tz('UTC').format('hh:mm:ss A');
        document.getElementById("frntim").innerText = momentProxy().tz('Europe/Paris').format('hh:mm:ss A');
    }, 250);
    var fToC = (input) => (input - 32) * 5 / 9;
    var cToF = (input) => (input * 9 / 5) + 32;
    var dp = (h, t) => Math.pow(h / 100, 1 / 8) * (112 + 0.9 * t) + 0.1 * t - 112;
    var dpF = (h, t) => cToF(dp(h, fToC(t)));
    (function() {
        var mouseTimer = null,
            cursorVisible = true;

        function disappearCursor() {
            mouseTimer = null;
            document.body.style.cursor = "none";
            cursorVisible = false;
        }

        document.onmousemove = function() {
            if (mouseTimer) {
                window.clearTimeout(mouseTimer);
            }
            if (!cursorVisible) {
                document.body.style.cursor = "default";
                cursorVisible = true;
            }
            mouseTimer = window.setTimeout(disappearCursor, 500);
        };
    })();
    var dformat = 'ddd';

    function getWeather() {
        document.getElementById("day").innerText = momentProxy().format('MMM Do YYYY')
        document.getElementById("wday").innerText = momentProxy().format(dformat)
        if (appid) fetch(`https://api.openweathermap.org/data/2.5/weather?zip=44720,US&appid=${appid}&units=imperial`)
            .then(response => response.json())
            .then(data => {
                var feelsLike = Math.round(data.main.feels_like);
                var dp = Math.round(dpF(data.main.humidity, data.main.temp));
                console.log(data);
                document.getElementById("temp").innerText = `${feelsLike}°`;
                document.getElementById("dp").innerText = `/${dp}°`;
                document.getElementById("wday").innerText = momentProxy().format(dformat)
            });
    }
    getWeather();
    setInterval(getWeather, 1000 * 60 * 20);




    
    




    </script>


        </content>
    </div>
</body>

</html>